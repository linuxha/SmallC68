,pn 76
,pl 66
,lm 8
,ll 64
,ju
,ppsi 4
,ppsp 1
,pc `
,hd
,ll 64
`$1B,'!,24`
,ce 2
Output Macros and Optimisation

`$1B,'!,8`
,,
,ft
,ll 64
`$1B,'!,24`
,ce 3
###

Silicon Fen Software
`$1B,'!,0`
,,


`$1B,'!,24`
,ce 2
8. Output Macros and Optimisation

`$1B,'!,8`
,pp
The output from the compiler is in a processor independent macro language which can be used to generate machine code for several different microprocessors by simply redefining the macro's. Macro's are currently available for 6809 and 6801 use and macro sets for the 68000 is under development. It is possible to develop a small-C program on a 6809 FLEX machine and when it has been tested, the macro's can be reassembled (without being recompiled) for a 6801 using 6801 macro definitions and runtime library. This code can then be put into EPROM or whatever and then run on the target machine.
,pp
The macros are defined in LIBM09.TXT for the 6809 and they will not be described any further here. Users are welcome to redefine the macro's for new processors using the 6809 versions as a guide and Silicon Fen Software would like to know if anyone succeeds in this. 
,pp
Section 7 describes the special method used to pass the number of parameters to a function. Some extra information is also available when a function is defined. The FUNC macro is passed the number of arguments that were declared with the function. This is not the number of bytes, it is the number of words. This is used by the FUNC macro to see how many arguments the function "main" was defined with. This number is saved as _MARGS and later on the code that parses the FLEX command line is only present if it is needed. This saves a few hundred bytes.
,pp
When generating code the compiler always assumes the worst so that for simple constructs the code generated may be inefficient. For example when a constant array index is used the compiler still calculates the resulting array element address at runtime rather than at compile time. This applies even if the constant is zero. The code for accessing stack based variables is also inefficient. The optimiser program opt.cmd is provided to remove some of the redundant code sequences. The optimiser is a small-C program (the source code is provided in OPT.C) which works on the macros output from the compiler, looking for sequences of macros which can be replaced by a more efficient macro. Some of the defined macros in LIBM09.TXT are never generated by the compiler but are inserted by the optimiser. The optimiser is currently very simple in operation and is coded as a nest of if() else statements. The current version saves about 10-15% on the size of the code segment for a program. The current optimiser doesnt optimise constant array indexes but the user can modify OPT.C to increase the range of optimisations it performs. A lot of testing is needed to verify that an optimisation is valid in all situations.
,pp
One extra advantage of using processor independent macros is that a single version of the optimiser will optimise code for any target processor. The current optimisations are set up to take advantage of the 6809 instruction set so the savings may not be as good for other processors but there should always be some savings

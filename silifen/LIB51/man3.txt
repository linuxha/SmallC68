,pn 12
,pl 66
,lm 8
,ll 64
,ju
,ppsi 4
,ppsp 1
,pc `
,hd
,ll 64
`$1B,'!,24`
,ce 2
Compiler Operation

`$1B,'!,8`
,,
,ft
,ll 64
`$1B,'!,24`
,ce 3
###

Silicon Fen Software
`$1B,'!,0`
,,
`$1B,'!,24`

,ce
3.  Compiler Operation
`$1B,'!,8`
,pp
The compiler has two modes of operation, command line mode and interactive mode. In each mode there are four main options.
,pp
Command line mode is similar to the Unix method of invoking the Unix C compiler. All the parameters are passed on the command line as with FLEX commands like the assembler etc. The syntax is shown below:

        +++cc infile1 [infile2....] [-o outfile] [-4dimnNNN]

,pp
The +++ sign is the FLEX prompt. cc invokes the compiler cc.cmd which sees that there is more than one argument on the command line and reads the rest of the line for its files and options. There must be at least one input file specified (no extension is assumed so the full name must be given) and there can be up to 14 input files on the command line. The [infile2....] indicates that all the other input files are optional.
,pp
An output filename can be specified on the command line at any point. Its name must be preceded by the -o (lower case o only) to distinguish the output filename from all the input filenames. The space between the -o and the output filename is optional.
,pp
At any point along the command line some options can be specified. These are introduced by a - and the possible options are listed below:
,pp
-4 is used with the 68000 code generation option. The compiler generates code as if all integers and pointers were 4 byte, 32 bit, values instead of 16 bit values. Odd addresses are also avoided. This option is not yet supported properly as the 68000 option is not available. A -2 option is recognised but it is redundant as 2 byte, 16 bit, operation is the default.
,pp
-d is used to extract diagnostic information from the compilers internal tables. It causes a printout after a compilation which gives the number of errors found, the number of global symbols declared, the number of #define substitution characters stored and the number of literal string characters stored.
,pp
-i makes the compiler interleave the C program as comments in the output macro file (useful for debugging).
,pp
-m is used to compile a module (the global variables are not allocated and the runtime library is not included).
,pp
-nNNN sets the starting label number for the internally generated labels to NNN where NNN is a decimal number.
,pp
The options can be specified together with two restrictions. They cannot be combined with -o, and -n (if present) must be the last option in the combination.
,pp
If there are any errors in the command line then the compiler aborts and prints an error message. If no output filename is specified then the compiler will prompt for one interactively.

e.g.

        +++cc fred.c -o fred.m
        +++cc -o fred.m fred.c
        +++cc fred.c -ofred.m

,pp
The above commands are identical and cause fred.c to be compiled into macro's in fred.m.

        +++cc fred.c
        output filename: fred.m

,pp
This time no output file was specified and the compiler prompted for an output filename which was given as fred.m .


        +++cc fred1.c fred2.c fred3.c -o fred.m

        +++cc fred1.c -o fred.m fred2.c fred3.c
,pp
This time three input filenames were specified and they are compiled in turn to produce a single output file called fred.m. Both the above commands have the same result.

        +++cc fred.c -i -o fred.m
,pp
This time the output file contains each line of the input file as a comment just before the code that was generated by that line. The output file can be assembled to produce a normal binary but it takes up more space on the disk and the comments may prevent the optimiser from performing a full optimisation.

        +++cc fred.h fred1.c -mn1000 -o fred1.m
        +++cc fred.h fred2.c -mn2000 -o fred2.m
        +++cc fred.h fred1.m fred2.m -o fred.m
,pp
This is an example of the module option. The following description should be skipped on the first reading of the manual. fred1.c and fred2.c are compiled separately to fred1.m and fred2.m with the -m option. fred.h contains all the #defines and global variable declarations for the final program (see section 4.6 for an explanation of global variables). The output files do not contain global variable declarations or directives to include the runtime library files. They have #asm inserted at the top and #endasm inserted at the bottom and cannot be assembled directly.
,pp
The third compilation does not have the -m option as it is used to generate a file which can be assembled. The header file fred.h is compiled on its own to provide the required global variable declarations then the two output files from the previous compilations are passed through the compiler as blocks of assembler (due to the #asm and #endasm directives), this is much faster than recompiling the source files. The result is placed in fred.m and has the globals defined as well as the library include directives.
,pp
If a large program is compiled as modules as shown above then if there is a change to one module then only that module needs to be recompiled. All the modules are then recombined using the compiler. If a change is made to the header file which contains all the globals then all the modules must be recompiled.
,pp
The -nNNN directive is needed so that the compilers internally generated labels do not clash. Each module must have a different starting point and the starting points must be spaced far enough apart. The assembler will generate an error of the form *** CC123 IS MULTIPLY DEFINED *** if the labels clash.
,pp
The command line mode has two limitations. The first is that all the source and output files as well as the compiler must be present on disk together. The second is that only up to 15 separate words can be passed on the command line. If more are typed then the compiler will see the 15th word as containing the rest of the command line. Because the compilers name (cc) takes up the first word a maximum of 14 files can be compiled together (specifying the output file name interactively).
,pp
The alternative to command line mode is interactive mode. By specifying no parameters on the command line except the compiler name (cc), the compiler will obtain all its filenames and options interactively.
,pp
The compiler can be invoked from a disk which is removed after the compiler has output its prompt and replaced by a disk containing the source and space for the output files. This saves about 100 blocks (the size of the compiler command) which is significant for users who have a single disk drive.
,pp
The compiler prints a banner which specifies the release number and then sets up the possible options. These default to sensible values if return is typed after each prompt. The output file is then specified. MAKE SURE THAT YOU DONT TYPE THE INPUT FILENAME BY MISTAKE AS ANY FILES EXISTING WITH THIS NAME WILL BE DELETED. The compiler's output can be sent to the screen instead of a file by typing return instead of giving a filename. The compiler then prompts for input filenames, compiling each in turn. There is no limit to the number of input files which can be specified in this way but the names have to be entered one at a time. The command line mode lets the user give all the files in one go but in interactive mode the user has to wait for each file to be compiled before specifying the next.
,pp
When all the files have been compiled type return and the compiler will exit to FLEX. There is a delay while the string literals and global variables are written to the output file.
e.g.
        +++cc

        Silicon Fen Software: small-C compiler R1.1 4/7/85
        
        Interleave source as comments (y/*n): n
        Declare global variables (*y/n)     : y
        Generate 32 bit macro code (y/*n)   : n
        Starting number for labels (*0)     : 0
        output filename: fred.m
        input filename: fred.c
        input filename:                 (type return)

        +++

,pp
When the compiler has finished you will need to run the optimiser on the macro file to improve the code efficiency and then assemble the optimised macro file to produce an executable flex command.
,pp
The optimiser is provided as source code in opt.c and as a command, opt.cmd. The syntax and version of the optimiser can be discovered by invoking the optimiser with no arguments.

        +++opt
        Optimiser R1.1 3/7/85 useage: opt infile [outfile]

        +++
,pp
The optimiser takes a macro file as input and outputs an optimised macro file. If no output filename is specified then the output is displayed on the screen. This is useful when testing the optimiser.

        +++opt fred.m fred.om

        +++
,pp
There is no message displayed by the optimiser in normal use as shown above. The filename suffixes .m and .om are a suggested convention only. The full filename must always be specified.
,pp
The standard flex assembler is used with this compiler. No other assembler is known to work and certainly MACE and CRASMB do not work. The main problem with MACE is that it does not support macros, CRASM has macros but doesnt distinguish between upper and lower case which is a neccesary feature.
,pp
The TSC assembler is usually invoked as shown below.

        +++asmb fred.om fred.cmd +ls

,pp
The options +ls suppress the assembly listing and the symbol table. The assembly listing is very boring unless the compilers -i option has been used and low level debugging is in progress. The listing consists of the macro calling lines only and doesn't print the op codes generated for each macro. To get this information the assembler needs to have the line OPT EXP inserted in the file. This can be done for a single file by using the #asm directive at the top of the C file. e.g.

#asm
 OPT EXP        expand macro calls
#endasm

,pp
Alternatively the file LIBDEF09.TXT could be modified to include the OPT EXP. Note that LIBDEF.TXT is the file that is used and should be a copy of LIBDEF09.TXT for 6809 use.
,pp
When a second try at a program is being assembled the assembler prompts with DELETE EXISTING FILE? before it overwrites the first try. This can be prevented using the +y option on the command line.

        +++asmb fred.om fred.cmd +lsy

,pp
Finally, when a small-C program is run it can access the command line that invoked it. The text on the command line is converted into words separated by spaces in a private buffer in the program. This is passed to the main function as an array of pointers, each one of which points at one word from the command line. The name of the program is also passed as the first word and the number of words is passed to main as well. The correspondence is shown below using the standard names.

        +++fred param1   param2   param3,and,more param4

        argv[0] argv[1]  argv[2]  argv[3]         argv[4]

        "fred"  "param1" "param2" "param3,and,more" "param4"

        argc, the argument count, will be 5.
,pp
The current command line parser code reserves space for up to 15 words on the command line only. Any extra words will be included into argv[14]. This is the reason for the limit on the number of files that can be passed to cc for compilation. cc is compiled using itself. In fact, when a change is made to the compiler the old version is used to compile the new version. The new version is then used to compile itself and then that version is used to compile itself again. The last two versions are checked to make sure that they are byte for byte identical. The compiler is then used extensively before being accepted as a valid release. The previous R0.1 compiler command was unchanged from serial number 1 in November 1984 right through to August 1985 when R1.1 was released.
